#include QMK_KEYBOARD_H
#if __has_include("keymap.h")
#    include "keymap.h"
#endif

enum layer_names {
    _DEF,
    _NAV
};
/* THIS FILE WAS GENERATED!
 *
 * This file was generated by qmk json2c. You may or may not want to
 * edit it directly.
 */

const uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {
    [0] = LAYOUT(KC_GRV, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_DEL, KC_ESC, KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_EQL, KC_TAB, KC_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_QUOT, KC_BSLS, KC_Z, KC_X, KC_C, KC_V, KC_B, KC_MPLY, KC_NO, KC_N, KC_M, KC_COMM, KC_DOT, KC_SLSH, KC_MINS, KC_LALT, KC_LCTL, KC_LGUI, KC_LSFT, KC_SPC, KC_BSPC, KC_ENT, MO(1), KC_RSFT, KC_RALT),
    [1] = LAYOUT(KC_NO, KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, KC_F11, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_VOLU, KC_HOME, KC_UP, KC_END, KC_LCBR, KC_F12, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_VOLD, KC_LEFT, KC_DOWN, KC_RGHT, KC_RCBR, KC_CAPS, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_LPRN, KC_RPRN, KC_LBRC, KC_RBRC, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_NO, KC_TRNS, KC_NO, KC_NO)
};



#ifdef OTHER_KEYMAP_C
#    include OTHER_KEYMAP_C
#endif // OTHER_KEYMAP_C



#ifdef ENCODER_MAP_ENABLE
const uint16_t PROGMEM encoder_map[][NUM_ENCODERS][NUM_DIRECTIONS] = {
    [0] = { ENCODER_CCW_CW(KC_VOLD, KC_VOLU),  ENCODER_CCW_CW(LCTL(LSFT(KC_TAB)), LCTL(KC_TAB))  },
    [1] = { ENCODER_CCW_CW(KC_TRNS, KC_TRNS),  ENCODER_CCW_CW(KC_TRNS, KC_TRNS)  },
};
#endif


#ifdef OLED_ENABLE

// Animation parameters
#define FRAME_DURATION 500 // How long each frame lasts in milliseconds

// Animation variables

static uint32_t last_keypress_time = 0;
uint32_t timer = 0;
uint8_t current_frame = 0;

static void render_animation(void) {
    // Frame 1
    static const char epd_bitmap_frame_1_delay_0 [] PROGMEM = {
        // 'BongoCat1', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x80, 0x40, 0x40, 0x80, 0x80, 0x40, 0x20, 0x10, 0x10, 0x08, 0x06, 0x01, 0x02, 0x04,
        0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80, 0x40, 0x20, 0x10, 0xf0, 0x00,
        0x10, 0x1f, 0x10, 0x26, 0x23, 0x20, 0x23, 0x40, 0x40, 0x40, 0x40, 0x86, 0x80, 0x80, 0x8c, 0x18,
        0x10, 0x10, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x83, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x01, 0x01, 0x01, 0x02, 0x0e, 0x12, 0x21, 0x20, 0x20, 0x10, 0x10, 0x08, 0x08, 0x08, 0x0b, 0x1c
    };

    // Frame 2
    static const char epd_bitmap_frame_0_delay_0 [] PROGMEM = {
        // 'BongoCat2', 32x32px
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x10, 0x08, 0x06, 0x01, 0x02, 0x04,
        0x08, 0x10, 0x10, 0x20, 0x20, 0x40, 0x40, 0x40, 0x80, 0x80, 0x80, 0x40, 0x20, 0x10, 0xf0, 0x00,
        0x30, 0x48, 0x84, 0x82, 0x81, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x86, 0x80, 0x80, 0x8c, 0x18,
        0x10, 0x10, 0x00, 0x00, 0x30, 0x00, 0xe0, 0x10, 0xc8, 0x68, 0x10, 0x60, 0x00, 0x7c, 0x83, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
        0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 0x03, 0x04, 0x04, 0x04, 0x04, 0x08, 0x08, 0x08, 0x0b, 0x1c
    };

    // Animation frames array
    const char* epd_bitmap_allArray [] = {
        epd_bitmap_frame_0_delay_0,
        epd_bitmap_frame_1_delay_0
    };

    // Frame sizes array
    uint16_t frame_sizes[2] = {
        sizeof(epd_bitmap_frame_0_delay_0),
        sizeof(epd_bitmap_frame_1_delay_0)
    };

    // Run animation
    if (timer_elapsed(timer) > FRAME_DURATION) {
        // Set timer to updated time
        timer = timer_read();

        // Increment frame
        current_frame = (current_frame + 1) % (sizeof(epd_bitmap_allArray) / sizeof(epd_bitmap_allArray[0]));

        // Draw frame to OLED
        oled_write_raw_P(epd_bitmap_allArray[current_frame], frame_sizes[current_frame]);
    }
}


bool process_record_user(uint16_t keycode, keyrecord_t *record) {
    if (record->event.pressed) {
        last_keypress_time = timer_read32(); // Record current time
    }
    return true;
}


bool oled_task_user(void) {
    uint32_t idle_time = timer_elapsed32(last_keypress_time);
    if (idle_time > 15000) {
        oled_clear();
    } else {
        oled_set_cursor(0, 1);
        oled_write("LAYER", false);
        oled_set_cursor(1, 2);
        switch (get_highest_layer(layer_state)) {
            case _DEF :
                oled_write("DEF", false);
                break;
            case _NAV :
                oled_write("NAV", false);
                break;
        }

        oled_set_cursor(0, 4);
        led_t led_state = host_keyboard_led_state();
        switch (led_state.caps_lock) {
            case true :
                oled_write("CAPS", true);
                break;
            case false :
                oled_write("CAPS", false);
                break;
        }

        oled_set_cursor(0, 11);
        render_animation();
    }

    return false;
}
#endif
